\documentclass{book}
\usepackage{geometry,amsmath,amssymb,hyperref,calc,ifthen,alltt,theorem,capt-of,makeidx}
\usepackage{algorithm}
\usepackage{algpseudocode}
%%\usepackage{algorithmic}
\usepackage{xargs}
\usepackage{tikz}

\newtheorem{definition}{Definition}
\newcommand{\todo}[1]{}
\renewcommand{\todo}[1]{{\color{red} TODO: {#1}}}

\makeindex
\geometry{letterpaper}

\begin{document}
\title{{\Huge Polkadot Networking}\\
    {\Large Protocol Specification}}

\date{}
\maketitle
\tableofcontents
\newpage

\section{Introduction}

The Polkadot network is decentralized and does not rely on any central authority
or entity in order to achieve a its fullest potential of provided functionality.
Each node with the network can authenticate itself and its peers by using
cryptographic keys, including establishing fully encrypted connections. The
networking protocol is based on the open and standardized \verb|libp2p|
protocol, including the usage of the distributed Kademlia hash table for peer
discovery.

\subsection{Discovery mechanism}

The Polkadot Host uses varies mechanism to find peers within the network, to
establish and maintain a list of peers and to share that list with other peers
from the network.
\newline

The Polkadot Host uses various mechanism for peer dicovery.

\begin{itemize}
    \item Bootstrap nodes - hard-coded node identities and addresses provided by
    network configuration itself. Those addresses are selected an updated by the
    developers of the Polkadot Host. Node addresses should be selected based on
    a reputation metric, such as reliability and uptime.
    \item mDNS - performs a broadcast to the local network. Nodes that might be
    listing can respond the the broadcast.
    \item Kademlia requests - Kademlia supports \verb|FIND_NODE| requests, where
    nodes respond with their list of available peers.
\end{itemize}

\subsection{Connection establishment}

The Polkadot Host can establish a connection with any peer it knows the address.
\verb|libp2p| uses the \verb|multistream-select| protocol in order to establish
an encryption and multiplexing layer. The Polkadot Host supports multiple
base-layer protocols:

\begin{itemize}
    \item TCP/IP - addresses in the form of \verb|/ip4/1.2.3.4/tcp/| establish a
    TCP connection and negotiate a encryption and multiplexing layer.
    \item Websockets - addresses in the form of \verb|/ip4/1.2.3.4/ws/|
    establish a TCP connection and negotiate the Websocket protocol within the
    connection. Additionally, a encryption and multiplexing layer is negotiated
    within the Websocket connection.
    \item DNS - addresses in form of \verb|/dns/website.domain/tcp/| and
    \verb|/dns/website.domain/ws/|.
\end{itemize}

After a base-layer protocol is established, the Polkadot Host will apply the
Noise protocol.

\subsection{Substreams}

After the node establishes a connection with a peer, the use of multiplexing
allows the Polkadot Host to open substreams. Substreams allow the negotiation of
\textit{application-specific protocols}, where each protocol servers a specific
utility.

The Polkadot Host adoptes the following, standardized \verb|libp2p|
application-specific protocols:

\begin{itemize}
    \item \verb|/ipfs/ping/1.0.0| - Open a substream to a peer and initialize a
    ping to verify if a connection is till alive. If the peer does not respond,
    the connection is dropped.
    \item \verb|/ipfs/id/1.0.0| - Open a substream to a peer to ask information
    about that peer.
    \item \verb|/<protocol_id>/kad/| - Open a substream for Kademlia
    \verb|FIND_NODE| requests.
\end{itemize}

Additional, non-standardized protocols:

\begin{itemize}
    \item \verb|/<protocol-id>/sync/2| - a request and response protocol that
    allows the Polkadot Host to perform information about blocks.
    \item \verb|/<protocol-id>/light/2| - a request and response protocol that
    allows a light client to perform information about the state.
    \item \verb|/<protocol-id>/transactions/1| - a notification protocol which
    sends transactions to connected peers.
    \item \verb|/<protocol-id>/block-announces/1| - a notification protocol
    which sends blocks to connected peers.
\end{itemize}

\section{Network Messages}

\begin{definition}
    \label{defn-roles}
    The roles type, $R$, is a 8-bit unsigned integer indicating the role of the
    node. Following options are available: \todo{verify bitmask}

    \begin{itemize}
        \item \verb|0|: no network.
        \item \verb|1|: full node, does not participate in consensus.
        \item \verb|2|: light client node.
        \item \verb|4|: authory node.
    \end{itemize}
\end{definition}

\begin{definition}
    \label{defn-block-attributes}
    The block attributes, $B_{attr}$, is a 8-bit unsigned integer indicating the
    artifacts to request. \todo{verify bitmask}

    \begin{itemize}
        \item \verb|1|: include block header.
        \item \verb|2|: include block body
        \item \verb|4|: include block receipt
        \item \verb|8|: include block message queue.
        \item \verb|16|: include block justification.
    \end{itemize}
\end{definition}

\begin{definition}
    \label{defn-sequence-direction}
    Block enumeration direction is a varying data type of the following values:

    \begin{equation*}
      S_d =
      \begin{cases}
        0, & \text{enumerate in ascending order (from child to parent)} \\
        1, & \text{enumerate in descending order (from parent to canonical child}
      \end{cases}
    \end{equation*}
\end{definition}

\begin{definition}
    \label{defn-block-state}
    Block state in the chain is a varying data type of the following values:

    \begin{equation*}
      S_b =
      \begin{cases}
        0, & \text{Block is not part of the best chain} \\
        1, & \text{Latest best block}
      \end{cases}
    \end{equation*}
\end{definition}

\begin{definition}
    \label{defn-storage-proof}
    A proof that some set of key-value pairs are included in the storage trie. The proof contains
    the storage values so that the partial storage backend can be reconstructed by a verifier that
    does not already have access to the key-value pairs.
    \newline

    The proof consists of the set of serialized nodes in the storage trie accessed when looking up
    the keys covered by the proof. Verifying the proof requires constructing the partial trie from
    the serialized nodes and performing the key lookups

    \begin{alignat*}{2}
        S_p &:= (N_0, ... N_n) \\
        N &:= (b_0, ... b_n)
    \end{alignat*}

    where $N$ represents the node.
\end{definition}

\subsection{Status Packets}

A status message sent on connection.

\[
    M^S := (P_v, Min_v, R, B_n, B_h, G_h)
\]

where each value represents:

\begin{itemize}
    \item $P_v$: a UINT32 indicating the Protocol version.
    \item $Min_v$: a UINT32 indicating the minimum supported version.
    \item $R$: Supported roles (Def. \ref{defn-roles}).
    \item $B_n$: a UINT32 indicating the best block number.
    \item $B_h$: a 32-byte indicating the best block hash.
    \item $G_h$: a 32-byte indicating the genesis block hash.
\end{itemize}

\subsection{Block Request}\label{sect-block-request}

Request block from a peer.

\[
    M^B_Req := (R_{id}, B_{attr}, B_s, Option(B_e), S_d, Option(|\mathbb{B}|))
\]

where each value represents:

\begin{itemize}
    \item $R_{id}$: a UINT64 indicating the unique ID of a request.
    \item $B_{attr}$: block attributes to request (Def.
    \ref{defn-block-attributes}).
    \item $B_s$: indicates the starting point from this block, which can either
    be 32-byte block hash or a UINT32 block number.
    \item $Option(B_e)$: indicates the ending to the 32-byte hash. An
    implementation defined maximum is used when unspecified.
    \item $S_d$: sequence direction (Def. \ref{defn-sequence-direction}). 
    \item $Option(|\mathbb{B}|)$: maximum number of blocks to return. An implementation
    defined maximum is used when unspecified.
\end{itemize}

\subsection{Block Response}

Response to block request (Sect. \ref{sect-block-request}).

\[
    M^B_Res := (R_{id}, \mathbb{B})
\]

where each value represents:

\begin{itemize}
    \item $R_{id}$: a UINT64 indicating the ID of the request this response was
    made for.
    \item $\mathbb{B}$: an array containing the block data for the requested
    sequence.
\end{itemize}

\subsection{Block Announce}

Announce a new complete relay chain block on the network.

\[
    M^B_A := (H_b, Option(S_b), Option(D))
\]

where each value represents:

\begin{itemize}
    \item $H_b$: the new block header (Def. \todo{fabio}).
    \item $Option(S_b)$: block state (Def. \ref{defn-block-state}).
    \item $Option(D)$: a byte array containing the data associated with this
    block announcement. For example a candidate message.
\end{itemize}

\subsection{Transactions}

A collection of transactions, where each transaction is a byte array.

\begin{alignat*}{2}
    M^{Tx} &:= (T_0, ... T_n) \\
    T &:= (b_0, ... b_n)
\end{alignat*}

\subsection{Consensus Protocol}

A consensus message.

\[
    M^C_P := (e_{id}, D)
\]

where each value represents:

\begin{itemize}
    \item $e_{id}$: a 4-byte unique ID of the consensus engine.
    \item $D$: a byte array containing the message payload.
\end{itemize}

\subsection{Remote Method Call Request}

Remote call request.

\[
    M^{RMC}_{Req} := (R_{id}, B_h, M, D)
\]

where each value represents:

\begin{itemize}
    \item $R_{id}$: a UINT64 indicating the unique ID of a request.
    \item $B_h$: a 32-byte block hash at which to perform this call.
    \item $M$: a byte array containing a valid UTF-8 sequence indicating the
    method name.
    \item $D$: a byte array containing the call data.
\end{itemize}

\subsection{Remote Method Call Response}

Remote call response.

\[
    M^{RMC}_{Res} := (R_{id}, S_p)
\]

\begin{itemize}
    \item $R_{id}$: a UINT64 indicating the ID of the request this response was
    made for.
    \item $S_p$: a storage proof (Def. \ref{defn-storage-proof}).
\end{itemize}

\subsection{Remote Storage Read Request}

Remote storage read request.

\begin{alignat*}{2}
    M^{RSR}_{Req} &:= (R_{id}, B_h, (k_0, ..., k_n)) \\
    k &:= (b_0, ... b_n)
\end{alignat*}

where each value represents:

\begin{itemize}
    \item $R_{id}$: a UINT64 indicating the unique ID of a request.
    \item $B_h$: a 32-byte block hash at which to perform this call.
    \item $(k_0, ..., k_n)$: an array containing the storage keys.
\end{itemize}

\subsection{Remote Storage Read Response}

Remote storage read response.

\[
    M^{RSR}_{Res} := (R_{id}, S_p)
\]

where each value represents:

\begin{itemize}
    \item $R_{id}$: a UINT64 indicating the ID of the request this response was
    made for.
    \item $S_p$: a storage proof (Def. \ref{defn-storage-proof}).
\end{itemize}

\subsection{Remote Header Request}

Remote header request.

\[
    M^{RHR}_{Req} := (R_{id}, B_{nr})
\]

where each value represents:

\begin{itemize}
    \item $R_{id}$: a UINT64 indicating the unique ID of a request.
    \item $B_{nr}$: a UINT32 indicating the block number the header is for.
\end{itemize}

\subsection{Remote Header Response}

\[
    M^{RHR}_{Res} := (R_{id}, Option(H), S_p)
\]

where each value represents:

\begin{itemize}
    \item $R_{id}$: a UINT64 indicating the ID of the request this response was
    made for.
    \item $Option(H)$: the block header. This is \verb|None| if proof generation
    has failed (e.g. header is unknown)
    \item $S_p$: a storage proof (Def. \ref{defn-storage-proof}).
\end{itemize}

\subsection{Remote Changes Request}

\subsection{Remote Changes Response}

\subsection{Remote Child Storage Read Request}

\subsection{Remote Child Storage Read Response}

\subsection{Finality Proof Request}

\subsection{Finality Proof Response}

\subsection{Batch of Conensus Protocol Messages}

\end{document}