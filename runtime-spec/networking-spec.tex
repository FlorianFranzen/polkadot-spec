\documentclass{book}
\usepackage{geometry,amsmath,amssymb,hyperref,calc,ifthen,alltt,theorem,capt-of,makeidx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
%%\usepackage{algorithmic}
\usepackage{xargs}
\usepackage{tikz}

\newtheorem{definition}{Definition}
\newcommand{\todo}[1]{}
\renewcommand{\todo}[1]{{\color{red} TODO: {#1}}}

\makeindex
\geometry{letterpaper}

\begin{document}
\title{{\Huge Polkadot Networking}\\
    {\Large Protocol Specification}}

\date{}
\maketitle
\tableofcontents
\newpage

\section{Introduction}

The Polkadot network is decentralized and does not rely on any central authority
or entity in order to achieve a its fullest potential of provided functionality.
Each node with the network can authenticate itself and its peers by using
cryptographic keys, including establishing fully encrypted connections. The
networking protocol is based on the open and standardized \verb|libp2p|
protocol, including the usage of the distributed Kademlia hash table for peer
discovery.

\subsection{Discovery mechanism}

The Polkadot Host uses varies mechanism to find peers within the network, to
establish and maintain a list of peers and to share that list with other peers
from the network.
\newline

The Polkadot Host uses various mechanism for peer dicovery.

\begin{itemize}
    \item Bootstrap nodes - hard-coded node identities and addresses provided by
    network configuration itself. Those addresses are selected an updated by the
    developers of the Polkadot Host. Node addresses should be selected based on
    a reputation metric, such as reliability and uptime.
    \item mDNS - performs a broadcast to the local network. Nodes that might be
    listing can respond the the broadcast.
    \item Kademlia requests - Kademlia supports \verb|FIND_NODE| requests, where
    nodes respond with their list of available peers.
\end{itemize}

\subsection{Connection establishment}

The Polkadot Host can establish a connection with any peer it knows the address.
\verb|libp2p| uses the \verb|multistream-select| protocol in order to establish
an encryption and multiplexing layer. The Polkadot Host supports multiple
base-layer protocols:

\begin{itemize}
    \item TCP/IP - addresses in the form of \verb|/ip4/1.2.3.4/tcp/| establish a
    TCP connection and negotiate a encryption and multiplexing layer.
    \item Websockets - addresses in the form of \verb|/ip4/1.2.3.4/ws/|
    establish a TCP connection and negotiate the Websocket protocol within the
    connection. Additionally, a encryption and multiplexing layer is negotiated
    within the Websocket connection.
    \item DNS - addresses in form of \verb|/dns/website.domain/tcp/| and
    \verb|/dns/website.domain/ws/|.
\end{itemize}

After a base-layer protocol is established, the Polkadot Host will apply the
Noise protocol.

\subsection{Substreams}

After the node establishes a connection with a peer, the use of multiplexing
allows the Polkadot Host to open substreams. Substreams allow the negotiation of
\textit{application-specific protocols}, where each protocol servers a specific
utility.

The Polkadot Host adoptes the following, standardized \verb|libp2p|
application-specific protocols:

\begin{itemize}
    \item \verb|/ipfs/ping/1.0.0| - Open a substream to a peer and initialize a
    ping to verify if a connection is till alive. If the peer does not respond,
    the connection is dropped.
    \item \verb|/ipfs/id/1.0.0| - Open a substream to a peer to ask information
    about that peer.
    \item \verb|/<protocol_id>/kad/| - Open a substream for Kademlia
    \verb|FIND_NODE| requests.
\end{itemize}

Additional, non-standardized protocols:

\begin{itemize}
    \item \verb|/dot/sync/2| - a request and response protocol that
    allows the Polkadot Host to perform information about blocks.
    \item \verb|/dot/light/2| - a request and response protocol that
    allows a light client to perform information about the state.
    \item \verb|/dot/transactions/1| - a notification protocol which
    sends transactions to connected peers.
    \item \verb|/dot/block-announces/1| - a notification protocol
    which sends blocks to connected peers.
\end{itemize}

\section{Network Messages}

\subsection{API Package}

syntax = "proto3";
package api.v1;

\subsubsection{Block Request}

Request block data from a peer.

\begin{lstlisting}[frame=single]
message BlockRequest {
    // Bits of block data to request.
    uint32 fields = 1;
    // Start from this block.
    oneof from_block {
        // Start with given hash.
        bytes hash = 2;
        // Start with given block number.
        bytes number = 3;
    }
    // End at this block. An implementation defined
    // maximum is used when unspecified.
    bytes to_block = 4; // optional
    // Sequence direction.
    Direction direction = 5;
    // Maximum number of blocks to return. An implementation 
    // defined maximum is used when unspecified.
    uint32 max_blocks = 6; // optional
}

// Block enumeration direction
enum Direction {
    // Enumerate in ascending order
    // (from child to parent).
    Ascending = 0;
    // Enumerate in descending order 
    // (from parent to canonical child).
    Descending = 1;
}
\end{lstlisting}

\subsubsection{Block Response}

Response to Block Request.

\begin{lstlisting}[frame=single]
message BlockResponse {
    // Block data for the requested sequence.
    repeated BlockData blocks = 1;
} 

// Block data sent in the response.
message BlockData {
    // Block header hash.
    bytes hash = 1;
    // Block header if requested.
    bytes header = 2; // optional
    // Block body if requested.
    repeated bytes body = 3; // optional
    // Block receipt if requested.
    bytes receipt = 4; // optional
    // Block message queue if requested.
    bytes message_queue = 5; // optional
    // Justification if requested.
    bytes justification = 6; // optional
    // True if justification should be treated as present but
    // empty. This hack is unfortunately necessary because 
    // shortcomings in the protobuf format otherwise doesn't
    // make it possible to differentiate between a lack of 
    // justification and an empty justification.
    bool is_empty_justification = 7; // optional, false if absent
}
\end{lstlisting}

\end{document}